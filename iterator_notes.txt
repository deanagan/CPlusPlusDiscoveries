Iterators
 - are concepts of an object that represents positions of elements in a container.
 - not a pointer but rather, a generalization of a pointer, thus a pointer is an iterator but an iterator is not neccesarily a pointer.
 e.g. an iterator to a graph or tree is much more than a pointer.
 - iterators share the same interface but have different types

--------------------------------------
Iterator Functions:
begin() - represent the beginning of the elements in the container
end() - represents the position behind the last element, a past-the-end iterator
std::begin()/::end() free functions - same as member function begin/end. Prefer over member function for
uniformity as it can be used on C arrays.
next() - advances iterator to next element.
advance() - advances itertor to element by n steps.
prev() - moves iterator to previous element.

next() and advance() does not check whether it crosses the end() of a sequence
(it can’t check because iterators in general do not know the containers on which they operate).
Thus, calling this function might result in undefined behavior because calling operator ++ for
the end of a sequence is not defined.
prev() is the same, it doesn't check if it's past begin() and may result in undefined behavior.

iter_swap() - swap iterators

Ranged Base For Loops versus iterators.
Ranged based for loops are convenience interfaces only. THus, these are equivalents:
for (container_type elem : container) {
    ...
}

for (auto pos=container.begin(), end=container.end(); pos!=end; ++pos) {
    // take note elem is a copy of the element refered by pos. Thus it is
    // a good idea to make elem a reference/const reference to avoid unintentional copying.
    container_type elem = *pos;
    ...
}

- Iterators allow for working with vector without knowing the size beforehand.

Guidelines:
Use cbegin/cend for const_iterator.
next() and advance() does not check whether it crosses the end() of a sequence
(it can’t check because iterators in general do not know the containers on which they operate).
Thus, calling this function might result in undefined behavior because calling operator ++ for
the end of a sequence is not defined.
prev() is the same, it doesn't check if it's past begin() and may result in undefined behavior.

distance() - By using iterator tags, this function uses the best implementation according to
the iterator category. For random-access iterators, this function simply returns pos2-pos1.
Thus, for such iterators, distance() has constant complexity. For all other iterator categories,
pos1 is incremented until it reaches pos2 and the number of increments is returned. Thus, for
all other iterator categories, distance() has linear complexity. Therefore, distance() has bad
performance for other than random-access iterators. You should consider avoiding it.