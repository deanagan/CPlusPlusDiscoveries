Iterators
 - are concepts of an object that represents positions of elements in a container.
 - not a pointer but rather, a generalization of a pointer, thus a pointer is an iterator but an iterator is not neccesarily a pointer.
 e.g. an iterator to a graph or tree is much more than a pointer.
 - iterators share the same interface but have different types

--------------------------------------
Iterator Functions:
begin() - represent the beginning of the elements in the container
end() - represents the position behind the last element, a past-the-end iterator
std::begin()/::end() free functions - same as member function begin/end. Prefer over member function for
uniformity as it can be used on C arrays.
next() - advances iterator to next element.
advance() - advances itertor to element by n steps.
prev() - moves iterator to previous element.

next() and advance() does not check whether it crosses the end() of a sequence
(it can’t check because iterators in general do not know the containers on which they operate).
Thus, calling this function might result in undefined behavior because calling operator ++ for
the end of a sequence is not defined.
prev() is the same, it doesn't check if it's past begin() and may result in undefined behavior.

iter_swap() - swap values of the elements the given iterators are pointing to.

Ranged Base For Loops versus iterators.
Ranged based for loops are convenience interfaces only. THus, these are equivalents:
for (container_type elem : container) {
    ...
}

for (auto pos=container.begin(), end=container.end(); pos!=end; ++pos) {
    // take note elem is a copy of the element refered by pos. Thus it is
    // a good idea to make elem a reference/const reference to avoid unintentional copying.
    // e.g.
    // for (auto& elem : container) { }
    container_type elem = *pos;
    ...
}

- Iterators allow algorithms to work with containers without knowing the size beforehand.
The back_inserter/front_inserter/inserter are convenience function templates that
can be used for containers that support push_back/push_front/insert.



Guidelines:
Use cbegin/cend for const_iterator.
next() and advance() does not check whether it crosses the end() of a sequence
(it can’t check because iterators in general do not know the containers on which they operate).
Thus, calling this function might result in undefined behavior because calling operator ++ for
the end of a sequence is not defined.
prev() is the same, it doesn't check if it's past begin() and may result in undefined behavior.

distance() - By using iterator tags, this function uses the best implementation according to
the iterator category. For random-access iterators, this function simply returns pos2-pos1.
Thus, for such iterators, distance() has constant complexity. For all other iterator categories,
pos1 is incremented until it reaches pos2 and the number of increments is returned. Thus, for
all other iterator categories, distance() has linear complexity. Therefore, distance() has bad
performance for other than random-access iterators. You should consider avoiding it.

begin/end free function vs begin/end member function

In Modern C++, begin/end free functions are preferred over member functions. They do the
same thing that begin/end member functions do plus work on regular C-arrays.


Demo:
    std::vector<int> src(10);

    // Create range of numbers
    std::iota(begin(src), end(src), 1);
    std::copy(begin(src), end(src), std::ostream_iterator<int>(std::cout, ", "));
    std::cout << "--> Source numbers\n";


    std::vector<int> v;
    // Fill vector with source numbers but multiplied by 2
    std::transform(begin(src), end(src), std::back_inserter(v), [](int v) { return v*2; });
    std::copy(begin(v), end(v), std::ostream_iterator<int>(std::cout, ", "));
    std::cout << "--> vector contents\n";


    std::deque<int> d;
    // Copy previous vector into deque, but use front inserter to have a reverse effect
    std::copy(begin(v), end(v), std::front_inserter(d));
    std::copy(begin(d), end(d), std::ostream_iterator<int>(std::cout, ", "));
    std::cout << "--> deque contents\n";

    std::set<int> s;
    // Copy content of deque into set. Set doesn't support back and front inserter. We use inserter.
    // because sets are ordered, the output is reversed in ascending order.
    std::copy(begin(d), end(d), std::inserter(s, s.end()));
    std::copy(begin(s), end(s), std::ostream_iterator<int>(std::cout, ", "));
    std::cout << "--> set contents\n";